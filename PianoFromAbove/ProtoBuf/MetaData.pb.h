// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MetaData.proto

#ifndef PROTOBUF_MetaData_2eproto__INCLUDED
#define PROTOBUF_MetaData_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace PFAData
{

  // Internal implementation detail -- do not call these.
  void  protobuf_AddDesc_MetaData_2eproto();
  void protobuf_AssignDesc_MetaData_2eproto();
  void protobuf_ShutdownFile_MetaData_2eproto();

  class Label;
  class SongInfo;
  class FileInfo;
  class File;
  class MetaData;

  // ===================================================================

  class Label : public ::google::protobuf::MessageLite
  {
  public:
    Label();
    virtual ~Label();

    Label(const Label& from);

    inline Label& operator=(const Label& from)
    {
      CopyFrom(from);
      return *this;
    }

    static const Label& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const Label* internal_default_instance()
    {
      return default_instance_;
    }
#endif

    void Swap(Label* other);

    // implements Message ----------------------------------------------

    Label* New() const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const Label& from);
    void MergeFrom(const Label& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
    int GetCachedSize() const { return _cached_size_; }
  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
  public:

    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // required int32 pos = 1;
    inline bool has_pos() const;
    inline void clear_pos();
    static const int kPosFieldNumber = 1;
    inline ::google::protobuf::int32 pos() const;
    inline void set_pos(::google::protobuf::int32 value);

    // required string label = 2;
    inline bool has_label() const;
    inline void clear_label();
    static const int kLabelFieldNumber = 2;
    inline const ::std::string& label() const;
    inline void set_label(const ::std::string& value);
    inline void set_label(const char* value);
    inline void set_label(const char* value, size_t size);
    inline ::std::string* mutable_label();
    inline ::std::string* release_label();
    inline void set_allocated_label(::std::string* label);

    // @@protoc_insertion_point(class_scope:PFAData.Label)
  private:
    inline void set_has_pos();
    inline void clear_has_pos();
    inline void set_has_label();
    inline void clear_has_label();

    ::std::string* label_;
    ::google::protobuf::int32 pos_;

    mutable int _cached_size_;
    ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void  protobuf_AddDesc_MetaData_2eproto_impl();
#else
    friend void  protobuf_AddDesc_MetaData_2eproto();
#endif
    friend void protobuf_AssignDesc_MetaData_2eproto();
    friend void protobuf_ShutdownFile_MetaData_2eproto();

    void InitAsDefaultInstance();
    static Label* default_instance_;
  };
  // -------------------------------------------------------------------

  class SongInfo : public ::google::protobuf::MessageLite
  {
  public:
    SongInfo();
    virtual ~SongInfo();

    SongInfo(const SongInfo& from);

    inline SongInfo& operator=(const SongInfo& from)
    {
      CopyFrom(from);
      return *this;
    }

    static const SongInfo& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const SongInfo* internal_default_instance()
    {
      return default_instance_;
    }
#endif

    void Swap(SongInfo* other);

    // implements Message ----------------------------------------------

    SongInfo* New() const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const SongInfo& from);
    void MergeFrom(const SongInfo& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
    int GetCachedSize() const { return _cached_size_; }
  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
  public:

    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // required bytes md5 = 1;
    inline bool has_md5() const;
    inline void clear_md5();
    static const int kMd5FieldNumber = 1;
    inline const ::std::string& md5() const;
    inline void set_md5(const ::std::string& value);
    inline void set_md5(const char* value);
    inline void set_md5(const void* value, size_t size);
    inline ::std::string* mutable_md5();
    inline ::std::string* release_md5();
    inline void set_allocated_md5(::std::string* md5);

    // optional int32 division = 2;
    inline bool has_division() const;
    inline void clear_division();
    static const int kDivisionFieldNumber = 2;
    inline ::google::protobuf::int32 division() const;
    inline void set_division(::google::protobuf::int32 value);

    // optional int32 notes = 3;
    inline bool has_notes() const;
    inline void clear_notes();
    static const int kNotesFieldNumber = 3;
    inline ::google::protobuf::int32 notes() const;
    inline void set_notes(::google::protobuf::int32 value);

    // optional int32 beats = 4;
    inline bool has_beats() const;
    inline void clear_beats();
    static const int kBeatsFieldNumber = 4;
    inline ::google::protobuf::int32 beats() const;
    inline void set_beats(::google::protobuf::int32 value);

    // optional int32 seconds = 5;
    inline bool has_seconds() const;
    inline void clear_seconds();
    static const int kSecondsFieldNumber = 5;
    inline ::google::protobuf::int32 seconds() const;
    inline void set_seconds(::google::protobuf::int32 value);

    // optional int32 tracks = 6;
    inline bool has_tracks() const;
    inline void clear_tracks();
    static const int kTracksFieldNumber = 6;
    inline ::google::protobuf::int32 tracks() const;
    inline void set_tracks(::google::protobuf::int32 value);

    // optional int32 plays = 7;
    inline bool has_plays() const;
    inline void clear_plays();
    static const int kPlaysFieldNumber = 7;
    inline ::google::protobuf::int32 plays() const;
    inline void set_plays(::google::protobuf::int32 value);

    // @@protoc_insertion_point(class_scope:PFAData.SongInfo)
  private:
    inline void set_has_md5();
    inline void clear_has_md5();
    inline void set_has_division();
    inline void clear_has_division();
    inline void set_has_notes();
    inline void clear_has_notes();
    inline void set_has_beats();
    inline void clear_has_beats();
    inline void set_has_seconds();
    inline void clear_has_seconds();
    inline void set_has_tracks();
    inline void clear_has_tracks();
    inline void set_has_plays();
    inline void clear_has_plays();

    ::std::string* md5_;
    ::google::protobuf::int32 division_;
    ::google::protobuf::int32 notes_;
    ::google::protobuf::int32 beats_;
    ::google::protobuf::int32 seconds_;
    ::google::protobuf::int32 tracks_;
    ::google::protobuf::int32 plays_;

    mutable int _cached_size_;
    ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void  protobuf_AddDesc_MetaData_2eproto_impl();
#else
    friend void  protobuf_AddDesc_MetaData_2eproto();
#endif
    friend void protobuf_AssignDesc_MetaData_2eproto();
    friend void protobuf_ShutdownFile_MetaData_2eproto();

    void InitAsDefaultInstance();
    static SongInfo* default_instance_;
  };
  // -------------------------------------------------------------------

  class FileInfo : public ::google::protobuf::MessageLite
  {
  public:
    FileInfo();
    virtual ~FileInfo();

    FileInfo(const FileInfo& from);

    inline FileInfo& operator=(const FileInfo& from)
    {
      CopyFrom(from);
      return *this;
    }

    static const FileInfo& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const FileInfo* internal_default_instance()
    {
      return default_instance_;
    }
#endif

    void Swap(FileInfo* other);

    // implements Message ----------------------------------------------

    FileInfo* New() const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const FileInfo& from);
    void MergeFrom(const FileInfo& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
    int GetCachedSize() const { return _cached_size_; }
  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
  public:

    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // required .PFAData.SongInfo info = 1;
    inline bool has_info() const;
    inline void clear_info();
    static const int kInfoFieldNumber = 1;
    inline const ::PFAData::SongInfo& info() const;
    inline ::PFAData::SongInfo* mutable_info();
    inline ::PFAData::SongInfo* release_info();
    inline void set_allocated_info(::PFAData::SongInfo* info);

    // repeated .PFAData.Label label = 2;
    inline int label_size() const;
    inline void clear_label();
    static const int kLabelFieldNumber = 2;
    inline const ::PFAData::Label& label(int index) const;
    inline ::PFAData::Label* mutable_label(int index);
    inline ::PFAData::Label* add_label();
    inline const ::google::protobuf::RepeatedPtrField< ::PFAData::Label >&
      label() const;
    inline ::google::protobuf::RepeatedPtrField< ::PFAData::Label >*
      mutable_label();

    // @@protoc_insertion_point(class_scope:PFAData.FileInfo)
  private:
    inline void set_has_info();
    inline void clear_has_info();

    ::PFAData::SongInfo* info_;
    ::google::protobuf::RepeatedPtrField< ::PFAData::Label > label_;

    mutable int _cached_size_;
    ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void  protobuf_AddDesc_MetaData_2eproto_impl();
#else
    friend void  protobuf_AddDesc_MetaData_2eproto();
#endif
    friend void protobuf_AssignDesc_MetaData_2eproto();
    friend void protobuf_ShutdownFile_MetaData_2eproto();

    void InitAsDefaultInstance();
    static FileInfo* default_instance_;
  };
  // -------------------------------------------------------------------

  class File : public ::google::protobuf::MessageLite
  {
  public:
    File();
    virtual ~File();

    File(const File& from);

    inline File& operator=(const File& from)
    {
      CopyFrom(from);
      return *this;
    }

    static const File& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const File* internal_default_instance()
    {
      return default_instance_;
    }
#endif

    void Swap(File* other);

    // implements Message ----------------------------------------------

    File* New() const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const File& from);
    void MergeFrom(const File& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
    int GetCachedSize() const { return _cached_size_; }
  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
  public:

    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // required string fileName = 1;
    inline bool has_filename() const;
    inline void clear_filename();
    static const int kFileNameFieldNumber = 1;
    inline const ::std::string& filename() const;
    inline void set_filename(const ::std::string& value);
    inline void set_filename(const char* value);
    inline void set_filename(const char* value, size_t size);
    inline ::std::string* mutable_filename();
    inline ::std::string* release_filename();
    inline void set_allocated_filename(::std::string* filename);

    // required int32 fileSize = 2;
    inline bool has_filesize() const;
    inline void clear_filesize();
    static const int kFileSizeFieldNumber = 2;
    inline ::google::protobuf::int32 filesize() const;
    inline void set_filesize(::google::protobuf::int32 value);

    // required int32 infoPos = 3;
    inline bool has_infopos() const;
    inline void clear_infopos();
    static const int kInfoPosFieldNumber = 3;
    inline ::google::protobuf::int32 infopos() const;
    inline void set_infopos(::google::protobuf::int32 value);

    // @@protoc_insertion_point(class_scope:PFAData.File)
  private:
    inline void set_has_filename();
    inline void clear_has_filename();
    inline void set_has_filesize();
    inline void clear_has_filesize();
    inline void set_has_infopos();
    inline void clear_has_infopos();

    ::std::string* filename_;
    ::google::protobuf::int32 filesize_;
    ::google::protobuf::int32 infopos_;

    mutable int _cached_size_;
    ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void  protobuf_AddDesc_MetaData_2eproto_impl();
#else
    friend void  protobuf_AddDesc_MetaData_2eproto();
#endif
    friend void protobuf_AssignDesc_MetaData_2eproto();
    friend void protobuf_ShutdownFile_MetaData_2eproto();

    void InitAsDefaultInstance();
    static File* default_instance_;
  };
  // -------------------------------------------------------------------

  class MetaData : public ::google::protobuf::MessageLite
  {
  public:
    MetaData();
    virtual ~MetaData();

    MetaData(const MetaData& from);

    inline MetaData& operator=(const MetaData& from)
    {
      CopyFrom(from);
      return *this;
    }

    static const MetaData& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const MetaData* internal_default_instance()
    {
      return default_instance_;
    }
#endif

    void Swap(MetaData* other);

    // implements Message ----------------------------------------------

    MetaData* New() const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const MetaData& from);
    void MergeFrom(const MetaData& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
    int GetCachedSize() const { return _cached_size_; }
  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
  public:

    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // repeated .PFAData.File file = 1;
    inline int file_size() const;
    inline void clear_file();
    static const int kFileFieldNumber = 1;
    inline const ::PFAData::File& file(int index) const;
    inline ::PFAData::File* mutable_file(int index);
    inline ::PFAData::File* add_file();
    inline const ::google::protobuf::RepeatedPtrField< ::PFAData::File >&
      file() const;
    inline ::google::protobuf::RepeatedPtrField< ::PFAData::File >*
      mutable_file();

    // repeated .PFAData.FileInfo fileInfo = 2;
    inline int fileinfo_size() const;
    inline void clear_fileinfo();
    static const int kFileInfoFieldNumber = 2;
    inline const ::PFAData::FileInfo& fileinfo(int index) const;
    inline ::PFAData::FileInfo* mutable_fileinfo(int index);
    inline ::PFAData::FileInfo* add_fileinfo();
    inline const ::google::protobuf::RepeatedPtrField< ::PFAData::FileInfo >&
      fileinfo() const;
    inline ::google::protobuf::RepeatedPtrField< ::PFAData::FileInfo >*
      mutable_fileinfo();

    // @@protoc_insertion_point(class_scope:PFAData.MetaData)
  private:

    ::google::protobuf::RepeatedPtrField< ::PFAData::File > file_;
    ::google::protobuf::RepeatedPtrField< ::PFAData::FileInfo > fileinfo_;

    mutable int _cached_size_;
    ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void  protobuf_AddDesc_MetaData_2eproto_impl();
#else
    friend void  protobuf_AddDesc_MetaData_2eproto();
#endif
    friend void protobuf_AssignDesc_MetaData_2eproto();
    friend void protobuf_ShutdownFile_MetaData_2eproto();

    void InitAsDefaultInstance();
    static MetaData* default_instance_;
  };
  // ===================================================================


  // ===================================================================

  // Label

  // required int32 pos = 1;
  inline bool Label::has_pos() const
  {
    return (_has_bits_[0] & 0x00000001u) != 0;
  }
  inline void Label::set_has_pos()
  {
    _has_bits_[0] |= 0x00000001u;
  }
  inline void Label::clear_has_pos()
  {
    _has_bits_[0] &= ~0x00000001u;
  }
  inline void Label::clear_pos()
  {
    pos_ = 0;
    clear_has_pos();
  }
  inline ::google::protobuf::int32 Label::pos() const
  {
    return pos_;
  }
  inline void Label::set_pos(::google::protobuf::int32 value)
  {
    set_has_pos();
    pos_ = value;
  }

  // required string label = 2;
  inline bool Label::has_label() const
  {
    return (_has_bits_[0] & 0x00000002u) != 0;
  }
  inline void Label::set_has_label()
  {
    _has_bits_[0] |= 0x00000002u;
  }
  inline void Label::clear_has_label()
  {
    _has_bits_[0] &= ~0x00000002u;
  }
  inline void Label::clear_label()
  {
    if(label_ != &::google::protobuf::internal::kEmptyString)
    {
      label_->clear();
    }
    clear_has_label();
  }
  inline const ::std::string& Label::label() const
  {
    return *label_;
  }
  inline void Label::set_label(const ::std::string& value)
  {
    set_has_label();
    if(label_ == &::google::protobuf::internal::kEmptyString)
    {
      label_ = new ::std::string;
    }
    label_->assign(value);
  }
  inline void Label::set_label(const char* value)
  {
    set_has_label();
    if(label_ == &::google::protobuf::internal::kEmptyString)
    {
      label_ = new ::std::string;
    }
    label_->assign(value);
  }
  inline void Label::set_label(const char* value, size_t size)
  {
    set_has_label();
    if(label_ == &::google::protobuf::internal::kEmptyString)
    {
      label_ = new ::std::string;
    }
    label_->assign(reinterpret_cast<const char*>(value), size);
  }
  inline ::std::string* Label::mutable_label()
  {
    set_has_label();
    if(label_ == &::google::protobuf::internal::kEmptyString)
    {
      label_ = new ::std::string;
    }
    return label_;
  }
  inline ::std::string* Label::release_label()
  {
    clear_has_label();
    if(label_ == &::google::protobuf::internal::kEmptyString)
    {
      return NULL;
    }
    else
    {
      ::std::string* temp = label_;
      label_ = const_cast<::std::string*>(&::google::protobuf::internal::kEmptyString);
      return temp;
    }
  }
  inline void Label::set_allocated_label(::std::string* label)
  {
    if(label_ != &::google::protobuf::internal::kEmptyString)
    {
      delete label_;
    }
    if(label)
    {
      set_has_label();
      label_ = label;
    }
    else
    {
      clear_has_label();
      label_ = const_cast<::std::string*>(&::google::protobuf::internal::kEmptyString);
    }
  }

  // -------------------------------------------------------------------

  // SongInfo

  // required bytes md5 = 1;
  inline bool SongInfo::has_md5() const
  {
    return (_has_bits_[0] & 0x00000001u) != 0;
  }
  inline void SongInfo::set_has_md5()
  {
    _has_bits_[0] |= 0x00000001u;
  }
  inline void SongInfo::clear_has_md5()
  {
    _has_bits_[0] &= ~0x00000001u;
  }
  inline void SongInfo::clear_md5()
  {
    if(md5_ != &::google::protobuf::internal::kEmptyString)
    {
      md5_->clear();
    }
    clear_has_md5();
  }
  inline const ::std::string& SongInfo::md5() const
  {
    return *md5_;
  }
  inline void SongInfo::set_md5(const ::std::string& value)
  {
    set_has_md5();
    if(md5_ == &::google::protobuf::internal::kEmptyString)
    {
      md5_ = new ::std::string;
    }
    md5_->assign(value);
  }
  inline void SongInfo::set_md5(const char* value)
  {
    set_has_md5();
    if(md5_ == &::google::protobuf::internal::kEmptyString)
    {
      md5_ = new ::std::string;
    }
    md5_->assign(value);
  }
  inline void SongInfo::set_md5(const void* value, size_t size)
  {
    set_has_md5();
    if(md5_ == &::google::protobuf::internal::kEmptyString)
    {
      md5_ = new ::std::string;
    }
    md5_->assign(reinterpret_cast<const char*>(value), size);
  }
  inline ::std::string* SongInfo::mutable_md5()
  {
    set_has_md5();
    if(md5_ == &::google::protobuf::internal::kEmptyString)
    {
      md5_ = new ::std::string;
    }
    return md5_;
  }
  inline ::std::string* SongInfo::release_md5()
  {
    clear_has_md5();
    if(md5_ == &::google::protobuf::internal::kEmptyString)
    {
      return NULL;
    }
    else
    {
      ::std::string* temp = md5_;
      md5_ = const_cast<::std::string*>(&::google::protobuf::internal::kEmptyString);
      return temp;
    }
  }
  inline void SongInfo::set_allocated_md5(::std::string* md5)
  {
    if(md5_ != &::google::protobuf::internal::kEmptyString)
    {
      delete md5_;
    }
    if(md5)
    {
      set_has_md5();
      md5_ = md5;
    }
    else
    {
      clear_has_md5();
      md5_ = const_cast<::std::string*>(&::google::protobuf::internal::kEmptyString);
    }
  }

  // optional int32 division = 2;
  inline bool SongInfo::has_division() const
  {
    return (_has_bits_[0] & 0x00000002u) != 0;
  }
  inline void SongInfo::set_has_division()
  {
    _has_bits_[0] |= 0x00000002u;
  }
  inline void SongInfo::clear_has_division()
  {
    _has_bits_[0] &= ~0x00000002u;
  }
  inline void SongInfo::clear_division()
  {
    division_ = 0;
    clear_has_division();
  }
  inline ::google::protobuf::int32 SongInfo::division() const
  {
    return division_;
  }
  inline void SongInfo::set_division(::google::protobuf::int32 value)
  {
    set_has_division();
    division_ = value;
  }

  // optional int32 notes = 3;
  inline bool SongInfo::has_notes() const
  {
    return (_has_bits_[0] & 0x00000004u) != 0;
  }
  inline void SongInfo::set_has_notes()
  {
    _has_bits_[0] |= 0x00000004u;
  }
  inline void SongInfo::clear_has_notes()
  {
    _has_bits_[0] &= ~0x00000004u;
  }
  inline void SongInfo::clear_notes()
  {
    notes_ = 0;
    clear_has_notes();
  }
  inline ::google::protobuf::int32 SongInfo::notes() const
  {
    return notes_;
  }
  inline void SongInfo::set_notes(::google::protobuf::int32 value)
  {
    set_has_notes();
    notes_ = value;
  }

  // optional int32 beats = 4;
  inline bool SongInfo::has_beats() const
  {
    return (_has_bits_[0] & 0x00000008u) != 0;
  }
  inline void SongInfo::set_has_beats()
  {
    _has_bits_[0] |= 0x00000008u;
  }
  inline void SongInfo::clear_has_beats()
  {
    _has_bits_[0] &= ~0x00000008u;
  }
  inline void SongInfo::clear_beats()
  {
    beats_ = 0;
    clear_has_beats();
  }
  inline ::google::protobuf::int32 SongInfo::beats() const
  {
    return beats_;
  }
  inline void SongInfo::set_beats(::google::protobuf::int32 value)
  {
    set_has_beats();
    beats_ = value;
  }

  // optional int32 seconds = 5;
  inline bool SongInfo::has_seconds() const
  {
    return (_has_bits_[0] & 0x00000010u) != 0;
  }
  inline void SongInfo::set_has_seconds()
  {
    _has_bits_[0] |= 0x00000010u;
  }
  inline void SongInfo::clear_has_seconds()
  {
    _has_bits_[0] &= ~0x00000010u;
  }
  inline void SongInfo::clear_seconds()
  {
    seconds_ = 0;
    clear_has_seconds();
  }
  inline ::google::protobuf::int32 SongInfo::seconds() const
  {
    return seconds_;
  }
  inline void SongInfo::set_seconds(::google::protobuf::int32 value)
  {
    set_has_seconds();
    seconds_ = value;
  }

  // optional int32 tracks = 6;
  inline bool SongInfo::has_tracks() const
  {
    return (_has_bits_[0] & 0x00000020u) != 0;
  }
  inline void SongInfo::set_has_tracks()
  {
    _has_bits_[0] |= 0x00000020u;
  }
  inline void SongInfo::clear_has_tracks()
  {
    _has_bits_[0] &= ~0x00000020u;
  }
  inline void SongInfo::clear_tracks()
  {
    tracks_ = 0;
    clear_has_tracks();
  }
  inline ::google::protobuf::int32 SongInfo::tracks() const
  {
    return tracks_;
  }
  inline void SongInfo::set_tracks(::google::protobuf::int32 value)
  {
    set_has_tracks();
    tracks_ = value;
  }

  // optional int32 plays = 7;
  inline bool SongInfo::has_plays() const
  {
    return (_has_bits_[0] & 0x00000040u) != 0;
  }
  inline void SongInfo::set_has_plays()
  {
    _has_bits_[0] |= 0x00000040u;
  }
  inline void SongInfo::clear_has_plays()
  {
    _has_bits_[0] &= ~0x00000040u;
  }
  inline void SongInfo::clear_plays()
  {
    plays_ = 0;
    clear_has_plays();
  }
  inline ::google::protobuf::int32 SongInfo::plays() const
  {
    return plays_;
  }
  inline void SongInfo::set_plays(::google::protobuf::int32 value)
  {
    set_has_plays();
    plays_ = value;
  }

  // -------------------------------------------------------------------

  // FileInfo

  // required .PFAData.SongInfo info = 1;
  inline bool FileInfo::has_info() const
  {
    return (_has_bits_[0] & 0x00000001u) != 0;
  }
  inline void FileInfo::set_has_info()
  {
    _has_bits_[0] |= 0x00000001u;
  }
  inline void FileInfo::clear_has_info()
  {
    _has_bits_[0] &= ~0x00000001u;
  }
  inline void FileInfo::clear_info()
  {
    if(info_ != NULL) info_->::PFAData::SongInfo::Clear();
    clear_has_info();
  }
  inline const ::PFAData::SongInfo& FileInfo::info() const
  {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return info_ != NULL ? *info_ : *default_instance().info_;
#else
    return info_ != NULL ? *info_ : *default_instance_->info_;
#endif
  }
  inline ::PFAData::SongInfo* FileInfo::mutable_info()
  {
    set_has_info();
    if(info_ == NULL) info_ = new ::PFAData::SongInfo;
    return info_;
  }
  inline ::PFAData::SongInfo* FileInfo::release_info()
  {
    clear_has_info();
    ::PFAData::SongInfo* temp = info_;
    info_ = NULL;
    return temp;
  }
  inline void FileInfo::set_allocated_info(::PFAData::SongInfo* info)
  {
    delete info_;
    info_ = info;
    if(info)
    {
      set_has_info();
    }
    else
    {
      clear_has_info();
    }
  }

  // repeated .PFAData.Label label = 2;
  inline int FileInfo::label_size() const
  {
    return label_.size();
  }
  inline void FileInfo::clear_label()
  {
    label_.Clear();
  }
  inline const ::PFAData::Label& FileInfo::label(int index) const
  {
    return label_.Get(index);
  }
  inline ::PFAData::Label* FileInfo::mutable_label(int index)
  {
    return label_.Mutable(index);
  }
  inline ::PFAData::Label* FileInfo::add_label()
  {
    return label_.Add();
  }
  inline const ::google::protobuf::RepeatedPtrField< ::PFAData::Label >&
    FileInfo::label() const
  {
    return label_;
  }
  inline ::google::protobuf::RepeatedPtrField< ::PFAData::Label >*
    FileInfo::mutable_label()
  {
    return &label_;
  }

  // -------------------------------------------------------------------

  // File

  // required string fileName = 1;
  inline bool File::has_filename() const
  {
    return (_has_bits_[0] & 0x00000001u) != 0;
  }
  inline void File::set_has_filename()
  {
    _has_bits_[0] |= 0x00000001u;
  }
  inline void File::clear_has_filename()
  {
    _has_bits_[0] &= ~0x00000001u;
  }
  inline void File::clear_filename()
  {
    if(filename_ != &::google::protobuf::internal::kEmptyString)
    {
      filename_->clear();
    }
    clear_has_filename();
  }
  inline const ::std::string& File::filename() const
  {
    return *filename_;
  }
  inline void File::set_filename(const ::std::string& value)
  {
    set_has_filename();
    if(filename_ == &::google::protobuf::internal::kEmptyString)
    {
      filename_ = new ::std::string;
    }
    filename_->assign(value);
  }
  inline void File::set_filename(const char* value)
  {
    set_has_filename();
    if(filename_ == &::google::protobuf::internal::kEmptyString)
    {
      filename_ = new ::std::string;
    }
    filename_->assign(value);
  }
  inline void File::set_filename(const char* value, size_t size)
  {
    set_has_filename();
    if(filename_ == &::google::protobuf::internal::kEmptyString)
    {
      filename_ = new ::std::string;
    }
    filename_->assign(reinterpret_cast<const char*>(value), size);
  }
  inline ::std::string* File::mutable_filename()
  {
    set_has_filename();
    if(filename_ == &::google::protobuf::internal::kEmptyString)
    {
      filename_ = new ::std::string;
    }
    return filename_;
  }
  inline ::std::string* File::release_filename()
  {
    clear_has_filename();
    if(filename_ == &::google::protobuf::internal::kEmptyString)
    {
      return NULL;
    }
    else
    {
      ::std::string* temp = filename_;
      filename_ = const_cast<::std::string*>(&::google::protobuf::internal::kEmptyString);
      return temp;
    }
  }
  inline void File::set_allocated_filename(::std::string* filename)
  {
    if(filename_ != &::google::protobuf::internal::kEmptyString)
    {
      delete filename_;
    }
    if(filename)
    {
      set_has_filename();
      filename_ = filename;
    }
    else
    {
      clear_has_filename();
      filename_ = const_cast<::std::string*>(&::google::protobuf::internal::kEmptyString);
    }
  }

  // required int32 fileSize = 2;
  inline bool File::has_filesize() const
  {
    return (_has_bits_[0] & 0x00000002u) != 0;
  }
  inline void File::set_has_filesize()
  {
    _has_bits_[0] |= 0x00000002u;
  }
  inline void File::clear_has_filesize()
  {
    _has_bits_[0] &= ~0x00000002u;
  }
  inline void File::clear_filesize()
  {
    filesize_ = 0;
    clear_has_filesize();
  }
  inline ::google::protobuf::int32 File::filesize() const
  {
    return filesize_;
  }
  inline void File::set_filesize(::google::protobuf::int32 value)
  {
    set_has_filesize();
    filesize_ = value;
  }

  // required int32 infoPos = 3;
  inline bool File::has_infopos() const
  {
    return (_has_bits_[0] & 0x00000004u) != 0;
  }
  inline void File::set_has_infopos()
  {
    _has_bits_[0] |= 0x00000004u;
  }
  inline void File::clear_has_infopos()
  {
    _has_bits_[0] &= ~0x00000004u;
  }
  inline void File::clear_infopos()
  {
    infopos_ = 0;
    clear_has_infopos();
  }
  inline ::google::protobuf::int32 File::infopos() const
  {
    return infopos_;
  }
  inline void File::set_infopos(::google::protobuf::int32 value)
  {
    set_has_infopos();
    infopos_ = value;
  }

  // -------------------------------------------------------------------

  // MetaData

  // repeated .PFAData.File file = 1;
  inline int MetaData::file_size() const
  {
    return file_.size();
  }
  inline void MetaData::clear_file()
  {
    file_.Clear();
  }
  inline const ::PFAData::File& MetaData::file(int index) const
  {
    return file_.Get(index);
  }
  inline ::PFAData::File* MetaData::mutable_file(int index)
  {
    return file_.Mutable(index);
  }
  inline ::PFAData::File* MetaData::add_file()
  {
    return file_.Add();
  }
  inline const ::google::protobuf::RepeatedPtrField< ::PFAData::File >&
    MetaData::file() const
  {
    return file_;
  }
  inline ::google::protobuf::RepeatedPtrField< ::PFAData::File >*
    MetaData::mutable_file()
  {
    return &file_;
  }

  // repeated .PFAData.FileInfo fileInfo = 2;
  inline int MetaData::fileinfo_size() const
  {
    return fileinfo_.size();
  }
  inline void MetaData::clear_fileinfo()
  {
    fileinfo_.Clear();
  }
  inline const ::PFAData::FileInfo& MetaData::fileinfo(int index) const
  {
    return fileinfo_.Get(index);
  }
  inline ::PFAData::FileInfo* MetaData::mutable_fileinfo(int index)
  {
    return fileinfo_.Mutable(index);
  }
  inline ::PFAData::FileInfo* MetaData::add_fileinfo()
  {
    return fileinfo_.Add();
  }
  inline const ::google::protobuf::RepeatedPtrField< ::PFAData::FileInfo >&
    MetaData::fileinfo() const
  {
    return fileinfo_;
  }
  inline ::google::protobuf::RepeatedPtrField< ::PFAData::FileInfo >*
    MetaData::mutable_fileinfo()
  {
    return &fileinfo_;
  }


  // @@protoc_insertion_point(namespace_scope)

}  // namespace PFAData

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_MetaData_2eproto__INCLUDED